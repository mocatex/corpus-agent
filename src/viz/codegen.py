"""
Generate visualization code using an LLM based on user questions and database schema.
"""

from __future__ import annotations

import json
from openai import OpenAI
from dotenv import load_dotenv

from .schema_summary import schema_summary
from .extra_metadata_glimpse import extra_metadata_glimpse

load_dotenv()
client = OpenAI()


def generate_viz_code(question: str, final_answer: str, run_id: str) -> str:
    """
    Generate Python code for visualizations based on the given question and final answer.
    The LLM will get a summary of the database schema and a glimpse of the extra_metadata field.
    It will return Python code that uses matplotlib to create the visualizations.

    :param question: the original user question
    :param final_answer: the final answer generated by the pipeline
    :param run_id: the pipeline run ID
    :return: A string containing the generated Python code.
    """
    run_id = str(run_id)

    payload = {"question": question, "final_answer": final_answer, "run_id": run_id, "db_schema": schema_summary(),
               "rules": [
                   "Return ONLY Python code (no markdown).",
                   "Use matplotlib only (no seaborn required).",
                   "Use query_df(sql, params) for SQL. params must include {'run_id': run_id} if needed.",
                   "SQL parameter style MUST be SQLAlchemy named params, e.g. WHERE pra.run_id = :run_id (NEVER %(run_id)s).",
                   "Save figures ONLY via save_fig(fig, filename). filename must end with .png",
                   "Create at least 1 chart.",
                   "Do not read/write outside OUT_DIR.",
               ], "suggested_tables": ["pipeline_run_articles", "article_corpus", "pipeline_runs"],
               "extra_metadata_glimpse": extra_metadata_glimpse(run_id)}

    payload["rules"].append(
        "If you query extra_metadata JSONB, ONLY use keys present in extra_metadata_glimpse.keypaths/examples. "
        "Use Postgres JSON operators (->, ->>) and SQLAlchemy params (:run_id). Never use %(run_id)s."
    )

    resp = client.chat.completions.create(
        model="gpt-5-mini",
        messages=[
            {"role": "system", "content": "You generate Python code that produces plots from a Postgres DB."},
            {"role": "user", "content": json.dumps(payload, default=str)},
        ],
    )
    return resp.choices[0].message.content.strip()
